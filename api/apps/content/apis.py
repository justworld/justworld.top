# coding: utf-8
from django.conf import settings
from rest_framework.response import Response
from rest_framework.decorators import action
from rest_framework.viewsets import GenericViewSet
from rest_framework.mixins import ListModelMixin, RetrieveModelMixin
from rest_framework.authentication import TokenAuthentication
from rest_framework.permissions import AllowAny


class ArticleViewSet(GenericViewSet, ListModelMixin, RetrieveModelMixin):
    authentication_classes = (TokenAuthentication,)
    permission_classes = (AllowAny,)

    def list(self, request, *args, **kwargs):
        data = {"count": 52, "page_size": 15, "total_page": 4, "page": 1,
                "list": [{"id": 1, "createTime": 1552151378000, "updateTime": None,
                          "title": "关于本站和博主", "description": "关于本站和博主",
                          "author": "Bobbi", "content": None, "readNum": 5221,
                          "likeNum": 14102,
                          "cover": "http://oss.dblearn.cn/dbblog/20190303/18a6c1d2ed47494396462901ffe02f30.jpg",
                          "coverType": 1, "recommend": None, "categoryId": None,
                          "publish": None, "top": True, "contentFormat": None,
                          "tagList": [{"id": 1, "name": "本站相关", "type": 0},
                                      {"id": 2, "name": "关于", "type": 0}]},
                         {"id": 60, "createTime": 1584170805000, "updateTime": None,
                          "title": "这是一个招聘帖，内推！",
                          "description": "阿里新零售供应链招聘啦，社招校招岗位都有，欢迎来投",
                          "author": "Bobbi", "content": None, "readNum": 90,
                          "likeNum": 10, "cover": None, "coverType": 2,
                          "recommend": None, "categoryId": None, "publish": None,
                          "top": False, "contentFormat": None,
                          "tagList": [{"id": 29, "name": "招聘", "type": 0}]},
                         {"id": 58, "createTime": 1574578028000, "updateTime": None,
                          "title": "Java多线程JUC锁11——AbstractQueuedSynchronizer详解(3)",
                          "description": "AQS为继承它的实现类提供基础设施，如构建等待队列、控制同步状态等；其内部除了提供并发操作的核心方法以及等待队列操作外，还提供了一些模板方法让子类自己实现，AQS只关注内部公共方法实现，并不关心外部不同模式的实现。",
                          "author": "Bobbi", "content": None, "readNum": 274,
                          "likeNum": 130, "cover": None, "coverType": 2,
                          "recommend": None, "categoryId": None, "publish": None,
                          "top": False, "contentFormat": None,
                          "tagList": [{"id": 7, "name": "Java", "type": 0},
                                      {"id": 24, "name": "JUC锁", "type": 0}]},
                         {"id": 56, "createTime": 1573972105000, "updateTime": None,
                          "title": "Java多线程JUC锁10——AbstractQueuedSynchronizer详解(2)",
                          "description": "AQS为继承它的实现类提供基础设施，如构建等待队列、控制同步状态等；其内部除了提供并发操作的核心方法以及等待队列操作外，还提供了一些模板方法让子类自己实现，AQS只关注内部公共方法实现，并不关心外部不同模式的实现。",
                          "author": "Bobbo", "content": None, "readNum": 148,
                          "likeNum": 105, "cover": None, "coverType": 2,
                          "recommend": None, "categoryId": None, "publish": None,
                          "top": False, "contentFormat": None,
                          "tagList": [{"id": 7, "name": "Java", "type": 0},
                                      {"id": 24, "name": "JUC锁", "type": 0}]},
                         {"id": 55, "createTime": 1573401014000, "updateTime": None,
                          "title": "Java多线程JUC线程池06——ScheduledThreadPoolExecutor详解(2)",
                          "description": "ScheduledThreadPoolExecutor用于执行周期性或延时性的定时任务，它是在ThreadPoolExecutor的基础上实现的任务调度线程池，内部使用延时工作队列DelayedWorkQueue实现对任务的延时调度。",
                          "author": "Bobbi", "content": None, "readNum": 144,
                          "likeNum": 25, "cover": None, "coverType": 2,
                          "recommend": None, "categoryId": None, "publish": None,
                          "top": False, "contentFormat": None,
                          "tagList": [{"id": 7, "name": "Java", "type": 0},
                                      {"id": 28, "name": "JUC线程池", "type": 0}]},
                         {"id": 54, "createTime": 1572108862000, "updateTime": None,
                          "title": "Java多线程JUC线程池05——ScheduledThreadPoolExecutor详解(1)",
                          "description": "ScheduledThreadPoolExecutor用于执行周期性或延时性的定时任务，它是在ThreadPoolExecutor的基础上实现的任务调度线程池，内部使用延时工作队列DelayedWorkQueue实现对任务的延时调度",
                          "author": "Bobbi", "content": None, "readNum": 162,
                          "likeNum": 16, "cover": None, "coverType": 2,
                          "recommend": None, "categoryId": None, "publish": None,
                          "top": False, "contentFormat": None,
                          "tagList": [{"id": 7, "name": "Java", "type": 0},
                                      {"id": 28, "name": "JUC线程池", "type": 0}]},
                         {"id": 53, "createTime": 1572034845000, "updateTime": None,
                          "title": "Java多线程JUC线程池04——Callable、Future、FutureTask",
                          "description": "Runnable接口是针对单纯的无返回值任务，当我们需要获取线程的执行结果时，就需要用到它们。Callable用于产生结果，Future用于获取结果。",
                          "author": "Bobbi", "content": None, "readNum": 119,
                          "likeNum": 21, "cover": None, "coverType": 2,
                          "recommend": None, "categoryId": None, "publish": None,
                          "top": False, "contentFormat": None,
                          "tagList": [{"id": 7, "name": "Java", "type": 0},
                                      {"id": 28, "name": "JUC线程池", "type": 0}]},
                         {"id": 52, "createTime": 1572003126000, "updateTime": None,
                          "title": "Java多线程JUC线程池03——ThreadPoolExecutor解析(2)",
                          "description": "上一节中介绍了线程池的生命周期和数据结构，本章会通过分析线程池的源码，对线程池进行说明",
                          "author": "Bobbi", "content": None, "readNum": 99,
                          "likeNum": 53, "cover": None, "coverType": 2,
                          "recommend": None, "categoryId": None, "publish": None,
                          "top": False, "contentFormat": None,
                          "tagList": [{"id": 7, "name": "Java", "type": 0},
                                      {"id": 28, "name": "JUC线程池", "type": 0}]},
                         {"id": 51, "createTime": 1571874930000, "updateTime": None,
                          "title": "Java多线程JUC线程池02——ThreadPoolExecutor解析(1)",
                          "description": "ThreadPoolExecutor是线程池类。对于线程池，可以通俗的将它理解为\"存放一定数量线程的一个线程集合。线程池允许若个线程同时允许，允许同时运行的线程数量就是线程池的容量；当添加的到线程池中的线程超过它的容量时，会有一部分线程阻塞等待。线程池会通过相应的调度策略和拒绝策略，对添加到线程池中的线程进行管理。",
                          "author": "Bobbi", "content": None, "readNum": 99,
                          "likeNum": 71, "cover": None, "coverType": 2,
                          "recommend": None, "categoryId": None, "publish": None,
                          "top": False, "contentFormat": None,
                          "tagList": [{"id": 7, "name": "Java", "type": 0},
                                      {"id": 28, "name": "JUC线程池", "type": 0}]},
                         {"id": 50, "createTime": 1571853810000, "updateTime": None,
                          "title": "Java多线程JUC线程池01——线程池架构",
                          "description": "介绍JUC线程池架构及其示例", "author": "Bobbi",
                          "content": None, "readNum": 113, "likeNum": 12,
                          "cover": None, "coverType": 2, "recommend": None,
                          "categoryId": None, "publish": None, "top": False,
                          "contentFormat": None,
                          "tagList": [{"id": 7, "name": "Java", "type": 0},
                                      {"id": 28, "name": "JUC线程池", "type": 0}]},
                         {"id": 49, "createTime": 1571261499000, "updateTime": None,
                          "title": "Java多线程JUC锁09——AbstractQueuedSynchronizer详解(1)",
                          "description": "AQS为继承它的实现类提供基础设施，如构建等待队列、控制同步状态等；其内部除了提供并发操作的核心方法以及等待队列操作外，还提供了一些模板方法让子类自己实现，AQS只关注内部公共方法实现，并不关心外部不同模式的实现。",
                          "author": "Bobbi", "content": None, "readNum": 122,
                          "likeNum": 84, "cover": None, "coverType": 2,
                          "recommend": None, "categoryId": None, "publish": None,
                          "top": False, "contentFormat": None,
                          "tagList": [{"id": 7, "name": "Java", "type": 0},
                                      {"id": 24, "name": "JUC锁", "type": 0}]},
                         {"id": 47, "createTime": 1569798094000, "updateTime": None,
                          "title": "SpringBoot自动配置源码解析",
                          "description": "SpringBoot的出现可谓是大大提升了Java的开发体验。它集成了大量常用的第三方库配置，Spring Boot应用中这些第三方库几乎可以是零配置的开箱即用，大部分的 Spring Boot 应用都只需要非常少量的配置代码（基于 Java 的配置），开发者能够更加专注于业务逻辑。",
                          "author": "Bobbi", "content": None, "readNum": 156,
                          "likeNum": 15, "cover": None, "coverType": 2,
                          "recommend": None, "categoryId": None, "publish": None,
                          "top": False, "contentFormat": None,
                          "tagList": [{"id": 7, "name": "Java", "type": 0},
                                      {"id": 27, "name": "SpringBoot", "type": 0}]},
                         {"id": 46, "createTime": 1569077582000, "updateTime": None,
                          "title": "Java集合07——HashMap",
                          "description": "HashMap 是一个散列表，它存储的内容是键值对(key-value)映射",
                          "author": "Bobbi", "content": None, "readNum": 151,
                          "likeNum": 78, "cover": None, "coverType": 2,
                          "recommend": None, "categoryId": None, "publish": None,
                          "top": False, "contentFormat": None,
                          "tagList": [{"id": 26, "name": "Java集合", "type": 0},
                                      {"id": 7, "name": "Java", "type": 0}]},
                         {"id": 45, "createTime": 1569065451000, "updateTime": None,
                          "title": "Java集合06——Map框架",
                          "description": "Map 是一个键值对(key-value)映射接口。Map映射中不能包含重复的键；每个键最多只能映射到一个值",
                          "author": "Bobbi", "content": None, "readNum": 66,
                          "likeNum": 2, "cover": None, "coverType": 2,
                          "recommend": None, "categoryId": None, "publish": None,
                          "top": False, "contentFormat": None,
                          "tagList": [{"id": 7, "name": "Java", "type": 0},
                                      {"id": 26, "name": "Java集合", "type": 0}]},
                         {"id": 44, "createTime": 1568897710000, "updateTime": None,
                          "title": "Java集合05——LinkedList",
                          "description": "LinkedList 是一个继承于AbstractSequentialList的双向链表。它也可以被当作堆栈、队列或双端队列进行操作。",
                          "author": "Bobbi", "content": None, "readNum": 62,
                          "likeNum": 0, "cover": None, "coverType": 2,
                          "recommend": None, "categoryId": None, "publish": None,
                          "top": False, "contentFormat": None,
                          "tagList": [{"id": 26, "name": "Java集合", "type": 0},
                                      {"id": 7, "name": "Java", "type": 0}]}]}
        return Response(data)

    def retrieve(self, request, *args, **kwargs):
        data = {"id": 58, "createTime": 1574578028000, "updateTime": 1574926715000,
                "title": "Java多线程JUC锁11——AbstractQueuedSynchronizer详解(3)",
                "description": "AQS为继承它的实现类提供基础设施，如构建等待队列、控制同步状态等；其内部除了提供并发操作的核心方法以及等待队列操作外，还提供了一些模板方法让子类自己实现，AQS只关注内部公共方法实现，并不关心外部不同模式的实现。",
                "author": "Bobbi",
                "content": "在前两篇AQS文章中，以ReentrantLock为导向，讲解了AQS对独占模式下锁的各类操作；AQS还支持共享模式的锁操作，在JUC包中，ReentrantReadWriteLock类对共享模式有着经典的实现，本篇文章就以ReentrantReadWriteLock为导向，讲解AQS对共享模式的支持。\n\n## ReentrantReadWriteLock的基本架构\nReentrantReadWriteLock允许同时创建读锁和写锁，其中读锁是共享锁，而写锁是独占锁，因此它需要同时控制两种同步状态，且这两种同步状态是不同的。在ReentrantReadWriteLock中巧妙地使用Sync将state变量分成了两个部分分别用于控制两种同步状态，源码如下：\n\n```java\nabstract static class Sync extends AbstractQueuedSynchronizer {\n    private static final long serialVersionUID = 6317671515068378041L;\n\n    /*\n     * AQS提供的state是int类型的变量，占32位\n     * 在ReentrantReadWriteLock中需要同时表示独占和共享两种模式的加锁次数\n     * 因此将32位state分为两部分，高16位表示共享锁加锁次数，低16位表示独占锁加锁次数\n     * 因此共享和独占最多加锁次数为2^16 - 1，即65535次\n     */\n    // 该值是位移位数标识\n    static final int SHARED_SHIFT = 16;\n    /**\n     * 共享模式的计数器，65536, 0001 0000 0000 0000 0000\n     * 由于共享锁加锁次数占据高16位，因此每次加锁，需要加上第17位为1，其余位全为0的值，才能正确完成计数\n     */\n    static final int SHARED_UNIT = (1 << SHARED_SHIFT);\n    // 加锁的最大次数，即16位二进制最大表示的大小，65535, 1111 1111 1111 1111\n    static final int MAX_COUNT = (1 << SHARED_SHIFT) - 1;\n    // 计算独占模式的高位掩码，65535, 0001 0000 0000 0000 0000 - 1 -> 1111 1111 1111 1111\n    static final int EXCLUSIVE_MASK = (1 << SHARED_SHIFT) - 1;\n\n    /**\n     * 获取共享模式下加锁的次数\n     */\n    static int sharedCount(int c) {\n        // 无符号右移，将低16位抛弃后，得到的就是高16位，即共享锁加锁次数\n        return c >>> SHARED_SHIFT;\n    }\n\n    /**\n     * 获取独占模式下加锁的次数\n     */\n    static int exclusiveCount(int c) {\n        // c和0000 0000 0000 0000 1111 1111 1111 1111相与后，高16位被抛弃，得到低16位，即独占锁加锁次数\n        return c & EXCLUSIVE_MASK;\n    }\n    ...\n}\n```\n从源码可以得知，ReentrantReadWriteLock类的内部抽象类Sync继承自AQS类，state作为一个int类型的变量，在内存中存储的二进制长度为32位，因此Sync将state分为两部分，其中高16位代表共享锁的加锁次数，而低16位代表独占锁的加锁次数，通过一系列的运算实现，详细分析如下：\n- SHARED_SHIFT：这个常量的值恒定为16，代表在计算过程中需要用到的位移位数。\n- MAX_COUNT：代表加锁的最大次数；因为state分为两部分后，共享锁和独占锁的记录值最大只能是16位的二进制数，因此最大加锁次数为65535次（16位全为1，2^16 - 1），就是MAX_COUNT的值。\n- SHARED_UNIT：这个值是在更新共享锁时的计数单位；由于共享锁占据高16位，因此每次共享锁加锁次数加1，都需要加上第17位为1，其余位全为0的值，才能正确完成计数。\n- EXCLUSIVE_MASK：用于计算独占锁的高位掩码，通过将state值与该值相与，可以将state的高16位全部置为0，得到的就是低16位的值。\n\n同时，Sync提供了两个方法用于获取共享锁和独占锁的重入次数。sharedCount(int c)用于获取共享锁的重入次数，它的实现是将传入的c（具体使用中会传入state）进行无符号右移16位操作，右移后c值的低16位会被抛弃，高16位会被补0，得到的就是共享锁的重入次数。exclusiveCount(int c)用于获取独占锁的重入次数，它的实现是将传入的c（具体使用中会传入state）和EXCLUSIVE_MASK做与计算操作，计算后c值的高16位会被置为0，得到的低16位就是独占锁的重入次数。\n\n分析完ReentrantReadWriteLock对state的划分，我们考察一下ReentrantReadWriteLock对state的整体结构：\n\n```java\npublic class ReentrantReadWriteLock implements ReadWriteLock, java.io.Serializable {\n    private final ReentrantReadWriteLock.ReadLock readerLock;\n    /** Inner class providing writelock */\n    private final ReentrantReadWriteLock.WriteLock writerLock;\n    /** Performs all synchronization mechanics */\n    final Sync sync;\n\n    public ReentrantReadWriteLock(boolean fair) {\n        sync = fair ? new FairSync() : new NonfairSync();\n        readerLock = new ReadLock(this);\n        writerLock = new WriteLock(this);\n    }\n\n    public ReentrantReadWriteLock.WriteLock writeLock() {\n        return writerLock;\n    }\n\n    public ReentrantReadWriteLock.ReadLock  readLock()  {\n        return readerLock;\n    }\n\n    abstract static class Sync extends AbstractQueuedSynchronizer { ... }\n\n    static final class NonfairSync extends Sync { ... }\n\n    static final class FairSync extends Sync { ... }\n\n    public static class ReadLock implements Lock, java.io.Serializable { ... }\n\n    public static class WriteLock implements Lock, java.io.Serializable { ... }\n}\n```\n\n可以看到ReentrantReadWriteLock在公平锁与非公平锁的实现上与ReentrantLock一样，有NonfairSync和FairSync两个都继承Sync的类，通过构造函数传入的布尔值决定要构造哪一种Sync实例。\n\nReentrantReadWriteLock比ReentrantLock多出了两个内部类：ReadLock和WriteLock， 用来定义读锁和写锁，然后在构造函数中，会构造一个读锁和一个写锁实例保存到成员变量readerLock和writerLock，readLock()和writeLock()方法就是用于返回这两个成员变量保存的锁实例。\n\n## 写锁分析\n我们先关注WriteLock类中的lock()和unlock()方法：\n```java\npublic void lock() {\n    sync.acquire(1);\n}\n\npublic void unlock() {\n    sync.release(1);\n}\n```\n\n可以发现lock()和unlock()方法分别调用了同步器的acquire(1)和release(1)方法，这里依旧以公平模式下的FairSync同步器为例；与ReentrantLock一样，ReentrantReadWriteLock类中FairSync的acquire(int)和release(int)方法也是来自父类Sync，而父类Sync的这两个方法来自于AQS：\n\n```java\npublic final void acquire(int arg) {\n    /**\n     * 这里的tryAcquire()会尝试获取同步状态\n     * 如果没有获取到，将会调用addWaiter()方法将当前线程包装为一个Node节点加入等待队列\n     * 然后对节点调用acquireQueued()方法使其进入自旋尝试获取同步的状态\n     * 加入成功后将中断当前线程\n     */\n    if (!tryAcquire(arg) && acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n        selfInterrupt();\n}\n\npublic final boolean release(int arg) {\n    if (tryRelease(arg)) {\n        Node h = head;\n        if (h != None && h.waitStatus != 0)\n            // 唤醒等待状态的线程\n            unparkSuccessor(h);\n        return True;\n    }\n    return False;\n}\n```\n这一步的实现其实与ReentrantLock是一模一样的，不同点在于此时acquire(int)方法中tryAcquire(int)和release(int)方法中的tryRelease(int)会调用ReentrantReadWriteLock类的Sync类重写的方法；先关注tryAcquire(int)方法的源码：\n\n```java\nprotected final boolean tryAcquire(int acquires) {\n    /*\n     * Walkthrough:\n     * 1. If read count nonzero or write count nonzero\n     *    and owner is a different thread, fail.\n     * 2. If count would saturate, fail. (This can only\n     *    happen if count is already nonzero.)\n     * 3. Otherwise, this thread is eligible for lock if\n     *    it is either a reentrant acquire or\n     *    queue policy allows it. If so, update state\n     *    and set owner.\n     */\n    Thread current = Thread.currentThread();\n    // state值\n    int c = getState();\n    // 获取独占锁的持有记录值\n    int w = exclusiveCount(c);\n    if (c != 0) {\n        /**\n         * (Note: if c != 0 and w == 0 then shared count != 0)\n         * 当c不为0时，表示独占锁和共享锁其中一个必然有被线程持有，分两种情况：\n         * 1. 当独占锁记录值为0，则此时共享锁必然被持有了，则获取独占锁失败，直接返回False\n         * 2. 当独占锁记录值不为0，即此时独占锁被持有了，就需要判断获取锁的线程是否就是当前拥有独占锁的线程，如果不是则获取独占锁失败，直接返回False\n         */\n        if (w == 0 || current != getExclusiveOwnerThread())\n            return False;\n        // 判断独占锁重入次数是否过多，导致记录值超过MAX_COUNT\n        if (w + exclusiveCount(acquires) > MAX_COUNT)\n            throw new Error(\"Maximum lock count exceeded\");\n        /**\n         * Reentrant acquire\n         * 获取独占锁成功，更新state的独占锁记录值\n         */\n        setState(c + acquires);\n        return True;\n    }\n    /**\n     * 此时state值为0，表示没有线程获取锁\n     * writerShouldBlock()底层调用了hasQueuedPredecessors()，用于判断同步队列是否有线程等待了很久\n     * 如果没有等待的线程，就尝试CAS方式修改state值，\n     * 如果修改失败说明此时有其他线程并发抢锁，而当前线程没抢到，直接返回False\n     */\n    if (writerShouldBlock() || !compareAndSetState(c, c + acquires))\n        return False;\n    // 抢锁成功，将独占锁线程设置为当前线程\n    setExclusiveOwnerThread(current);\n    return True;\n}\n```\n\n上面的源码已经将tryAcquire(int)方法的流程讲解地非常清楚了，这里需要注意的是，如果有线程持有了共享锁（读锁），那么获取独占锁（写锁）是失败的，即当有线程在进行读操作时，无法进行写操作。同时写操作同一时刻只允许一个线程进行。\n\n释放锁操作的tryRelease(int)方法比较简单，源码如下：\n```java\nprotected final boolean tryRelease(int releases) {\n    // 判断当前线程是否是拥有独占锁的线程，如果不是直接抛出异常\n    if (!isHeldExclusively())\n        throw new IllegalMonitorStateException();\n    // 计算释放锁后的state值\n    int nextc = getState() - releases;\n    // 判断独占锁记录值是否为0，如果为0表示可以释放独占锁了\n    boolean free = exclusiveCount(nextc) == 0;\n    if (free)\n        // 将拥有独占锁的线程记录变量设置为None，即释放独占锁\n        setExclusiveOwnerThread(None);\n    // 更新state值\n    setState(nextc);\n    // 返回值表示独占锁是否已被释放\n    return free;\n}\n```\n\nReentrantReadWriteLock类在写锁的获取和释放上与ReentrantLock相比，其实就只有上面更新state值的操作不一样，其他的类似获取锁不成功进入同步队列进行等待、被唤醒、重新抢锁等操作，其实就是AQS独占模式的应用，流程与ReentrantLock的流程是一模一样的，这里不再赘述。本文的重心在接下来的内容中。\n\n## 读锁分析\nReentrantReadWriteLock类的读锁，是典型的共享锁的应用，也是本文需要讲解的重心。类似于写锁，读锁的lock()和unlock()的实现实际对应Sync的tryAcquireShared(int)和tryReleaseShared(int)方法：\n\n```java\npublic void lock() {\n    sync.acquireShared(1);\n}\n\npublic void unlock() {\n    sync.releaseShared(1);\n}\n```\n\nacquireShared(int)和releaseShared(int)都属于AQS的方法，内部又调用了tryAcquireShared(int)和tryReleaseShared(int)：\n\n```java\npublic final void acquireShared(int arg) {\n    if (tryAcquireShared(arg) < 0)\n        // 获取失败将调用doAcquireShared()\n        doAcquireShared(arg);\n}\n\npublic final boolean releaseShared(int arg) {\n    if (tryReleaseShared(arg)) {\n        doReleaseShared();\n        return True;\n    }\n    return False;\n}\n```\n\n而tryAcquireShared(int)和tryReleaseShared(int)自然又是由ReentrantReadWriteLock的内部类Sync进行了重写。\n\n### 获取读锁\n\n我们先关注用于获取读锁（共享锁）的tryAcquireShared(int)方法的源码：\n\n```java\nprotected final int tryAcquireShared(int unused) {\n    /*\n     * Walkthrough:\n     * 1. If write lock held by another thread, fail.\n     * 2. Otherwise, this thread is eligible for\n     *    lock wrt state, so ask if it should block\n     *    because of queue policy. If not, try\n     *    to grant by CASing state and updating count.\n     *    Note that step does not check for reentrant\n     *    acquires, which is postponed to full version\n     *    to avoid having to check hold count in\n     *    the more typical non-reentrant case.\n     * 3. If step 2 fails either because thread\n     *    apparently not eligible or CAS fails or count\n     *    saturated, chain to version with full retry loop.\n     */\n    Thread current = Thread.currentThread();\n    // 获取state值\n    int c = getState();\n    /**\n     * 如果已经有线程获取了独占锁，且当前线程并不是拥有独占锁的线程，则获取共享锁失败，直接返回-1\n     * 从这里我们可以得知，拥有写锁的线程其实是可以同时拥有读锁的，这也是锁降级的实现，后面会讲解\n     */\n    if (exclusiveCount(c) != 0 && getExclusiveOwnerThread() != current)\n        return -1;\n    // 共享锁持有计数\n    int r = sharedCount(c);\n    /**\n     * 如果同步队列中没有线程已经等待了很久\n     * 且共享锁的计数小于最大阈值，则尝试修改state的值，即更新共享锁记录值\n     */\n    if (!readerShouldBlock() && r < MAX_COUNT && compareAndSetState(c, c + SHARED_UNIT)) {\n        // 能够进入if内部，表示更新共享锁记录值成功\n        if (r == 0) {\n            /**\n             * 如果r为0，则表示之前其实没有线程持有共享锁，\n             * 因此当前线程是第一个持有共享锁的线程，使用firstReader记录当前线程\n             * 同时设置firstReaderHoldCount为1\n             */\n            firstReader = current;\n            firstReaderHoldCount = 1;\n        } else if (firstReader == current) {\n            /**\n             * 如果r不为0，则判断当前线程是否是第一个持有共享锁的线程，\n             * 如果是，就将firstReaderHoldCount的值加1\n             */\n            firstReaderHoldCount++;\n        } else {\n            /**\n             * 走到这里，说明当前线程不是第一个获取共享锁的线程\n             * 需要在readHolds的本线程副本中记录当前线程重入数，readHolds是一个ThreadLocal类型的对象\n             * 这是为了实现JDK 1.6中加入的getReadHoldCount()方法的，\n             * 这个方法能获取当前线程重入共享锁的次数，\n             * 原理很简单：\n             * 如果当前只有一个线程的话，还不需要使用readHolds，直接更新firstReaderHoldCount来记录重入数，\n             * 当有第二个线程来的时候，就要使用readHolds，每个线程拥有自己的副本，用来保存自己的重入数。\n             */\n            HoldCounter rh = cachedHoldCounter;\n            if (rh == None || rh.tid != getThreadId(current))\n                cachedHoldCounter = rh = readHolds.get();\n            else if (rh.count == 0)\n                readHolds.set(rh);\n            rh.count++;\n        }\n        // 返回1，表示获取共享锁成功\n        return 1;\n    }\n    /**\n     * 走到这里，说明获取共享锁失败，会进入自旋抢锁；失败的情况有三种：\n     * 1. 当前同步队列已经有线程等待很久了；\n     * 2. 共享锁的计数太大，已经超过最大阈值；\n     * 3. CAS方式修改共享锁记录值失败\n     */\n    return fullTryAcquireShared(current);\n}\n```\n上面的源码对tryAcquireShared(int)方法的讲解已经比较清楚了，这里唯一需要注意的是，读锁记录了每个线程重入的次数，在内部实现上，如果仅仅只有一个线程多次重入获取了读锁，其实只会更新成员变量firstReaderHoldCount进行记录；一旦有多个线程获取了读锁，就会使用ThreadLocal类型的变量readHolds分别记录每个线程的重入次数。\n\ntryAcquireShared(int)方法的最后，当获取共享锁失败时，会调用fullTryAcquireShared(current)方法，该方法源码如下：\n\n```java\n/**\n * Full version of acquire for reads, that handles CAS misses\n * and reentrant reads not dealt with in tryAcquireShared.\n */\nfinal int fullTryAcquireShared(Thread current) {\n    /*\n     * This code is in part redundant with that in\n     * tryAcquireShared but is simpler overall by not\n     * complicating tryAcquireShared with interactions between\n     * retries and lazily reading hold counts.\n     */\n    HoldCounter rh = None;\n    for (; ; ) {\n        // state值\n        int c = getState();\n        if (exclusiveCount(c) != 0) {\n            // 如果已有线程持有独占锁，并且持有独占锁的线程不是当前线程，则表示获取失败，直接返回-1\n            if (getExclusiveOwnerThread() != current)\n                return -1;\n            // else we hold the exclusive lock; blocking here\n            // would cause deadlock.\n        } else if (readerShouldBlock()) {\n            // 走到这里表示可能需要阻塞当前线程\n            // Make sure we're not acquiring read lock reentrantly\n            if (firstReader == current) {\n                // assert firstReaderHoldCount > 0;\n                // 当前线程是第一个获取共享锁的线程，则继续往下执行\n            } else {\n                // 否则取得当前线程的获取锁的次数，如果次数为0，则表示获取失败，直接返回-1\n                if (rh == None) {\n                    rh = cachedHoldCounter;\n                    if (rh == None || rh.tid != getThreadId(current)) {\n                        rh = readHolds.get();\n                        if (rh.count == 0)\n                            readHolds.remove();\n                    }\n                }\n                if (rh.count == 0)\n                    return -1;\n            }\n        }\n        // 如果共享锁的计数等于最大阈值，抛出错误\n        if (sharedCount(c) == MAX_COUNT)\n            throw new Error(\"Maximum lock count exceeded\");\n        // CAS方式修改共享锁的计数\n        if (compareAndSetState(c, c + SHARED_UNIT)) {\n            if (sharedCount(c) == 0) {\n                /**\n                 * 如果sharedCount(c)为0，则表示之前其实没有线程持有共享锁，注意此时的c是修改前的共享锁的计数\n                 * 因此当前线程是第一个持有共享锁的线程，使用firstReader记录当前线程\n                 * 同时设置firstReaderHoldCount为1\n                 */\n                firstReader = current;\n                firstReaderHoldCount = 1;\n            } else if (firstReader == current) {\n                /**\n                 * 如果sharedCount(c)不为0，则判断当前线程是否是第一个持有共享锁的线程，\n                 * 如果是，就将firstReaderHoldCount的值加1\n                 */\n                firstReaderHoldCount++;\n            } else {\n                /**\n                 * 走到这里，说明当前线程不是第一个获取共享锁的线程\n                 * 需要在readHolds的本线程副本中记录当前线程重入数\n                 */\n                if (rh == None)\n                    rh = cachedHoldCounter;\n                if (rh == None || rh.tid != getThreadId(current))\n                    rh = readHolds.get();\n                else if (rh.count == 0)\n                    readHolds.set(rh);\n                rh.count++;\n                cachedHoldCounter = rh; // cache for release\n            }\n            // 返回1，表示获取共享锁成功\n            return 1;\n        }\n    }\n}\n```\n\n从源码可以看出fullTryAcquireShared(Thread)方法与tryAcquireShared(int)主要功能基本相同，不同的是fullTryAcquireShared(Thread)方法会进入自旋，在CAS方式修改state失败后在下一次循环重新尝试修改。同时，如果当前有线程获取了写锁（即独占锁），或者需要进行阻塞等待时，会返回-1。\n\n回到acquireShared(int)方法，当tryAcquireShared(int)在尝试修改state获取共享锁失败后会返回-1，因此会执行doAcquireShared(arg)，该方法源码如下：\n\n```java\nprivate void doAcquireShared(int arg) {\n    // 创建共享节点并添加到队列尾\n    final Node node = addWaiter(Node.SHARED);\n    boolean failed = True;\n    try {\n        boolean interrupted = False;\n        // 然后进行自旋，不断尝试获取同步状态\n        for (; ; ) {\n            final Node p = node.predecessor();\n            if (p == head) {\n                // 尝试获取共享锁\n                int r = tryAcquireShared(arg);\n                if (r >= 0) {\n                    // 获取共享锁成功，向后传递\n                    setHeadAndPropagate(node, r);\n                    p.next = None; // help GC\n                    if (interrupted)\n                        // 如果在等待期间出现中断，则重现中断操作\n                        selfInterrupt();\n                    failed = False;\n                    return;\n                }\n            }\n            /**\n             * 执行到此处，说明上面尝试获取锁失败了，因此可以尝试将当前线程挂起\n             * 这里的shouldParkAfterFailedAcquire()和parkAndCheckInterrupt()在之前已经讲解过了\n             */\n            if (shouldParkAfterFailedAcquire(p, node) &&\n                    parkAndCheckInterrupt())\n                interrupted = True;\n        }\n    } finally {\n        if (failed)\n            cancelAcquire(node);\n    }\n}\n```\n\ndoAcquireShared(int)与之前讲解的acquireQueued(final Node, int)方法非常类似，因此这里我们只关注在线程获取到锁之后执行的setHeadAndPropagate(node, r)方法，源码如下：\n```java\nprivate void setHeadAndPropagate(Node node, int propagate) {\n    // 记录旧的头节点，用于下面的各项检查\n    Node h = head; // Record old head for check below\n    // 当前节点的线程已获取到共享锁，因此将其该节点设置为头节点\n    setHead(node);\n    /*\n  \n     * propagate大于0时，表示当前线程已经获取到共享锁了，需要尝试唤醒下一个节点\n     * 如果旧的头节点为空，表示之前同步队列就是空的，没有线程在等待\n     * 如果旧的头节点不为空，但旧的头节点的waitStatus小于0（即为SIGNAL（-1）或者PROPAGATE（-3）），表示应该尝试唤醒后继节点\n     */\n    if (propagate > 0 || h == None || h.waitStatus < 0) {\n        /**\n         * 如果node的下一个节点为空，表示此时同步队列没有节点等待了，因此当前线程是最后一个获取共享锁的线程\n         * 或者node的下一个节点不为空，且是共享节点\n         * 就执行释放共享锁操作\n         */\n        Node s = node.next;\n        if (s == None || s.isShared())\n            doReleaseShared();\n    }\n}\n```\n\n与acquireQueued(final Node, int)方法中setHead()的实现不一样，setHeadAndPropagate(node, r)方法不仅将获取到共享锁的节点设置为头节点，并且进行了传播唤醒；查看doReleaseShared()的源码：\n\n```java\n/**\n * 共享模式的释放操作，将唤醒后继节点并保证传播性\n * 与独占模式不同，独占模式只会尝试唤醒后继节点\n */\nprivate void doReleaseShared() {\n    \n    for (; ; ) {\n        Node h = head;\n        if (h != None && h != tail) {\n            int ws = h.waitStatus;\n            if (ws == Node.SIGNAL) {\n                // 如果当前节点的waitStatus为SIGNAL，则尝试改为0，修改成功就唤醒头节点的后继节点锁包装的线程，修改失败重新尝试修改\n                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))\n                    continue;            // loop to recheck cases\n                // 这里会唤醒头节点的后继节点\n                unparkSuccessor(h);\n            } else if (ws == 0 && !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))\n                // 如果头节点的waitStatus为0，则尝试修改为PROPAGATE，如果修改失败则重新尝试修改\n                continue;                // loop on failed CAS\n        }\n        /**\n         * 由于头节点的后继节点所包装的线程被唤醒了，所以当被唤醒的线程获取到共享锁后，头节点可能会被修改；\n         * 因此当头节点被修改后，继续循环操作，开始下一轮的传播唤醒；\n         * 如果头节点没有被改变，说明此时虽然唤醒了后继节点，但后继节点并没有获取到共享锁，\n         * 因此直接break，将下一轮的传播唤醒操作交给后继节点\n         */\n        if (h == head)                   // loop if head changed\n            break;\n    }\n}\n```\n\ndoReleaseShared()整体是一个无限for循环，它会不断地尝试唤醒头节点的后继节点。这里我们着重分析一下该for循环的跳出条件h == head，h == head成立即表示在一次循环后，头节点没有被修改，那么什么时候头节点会被修改呢？假设当前线程获取到共享锁了，因此该线程所在的节点就是头节点（注意，此时头节点只是代表该线程，但该节点的thread被置为None了），头节点尝试唤醒它的后继节点后，如果后继节点成功获取到共享锁就会将自己设置为头节点，此时头节点就被修改了，h == head条件不成立，还会进入下一轮for循环，继续唤醒新的头节点的后继节点；头节点没有被修改的情况主要是：头节点唤醒的后继节点并不是共享节点，此时该节点的线程想获取独占锁，是会被阻塞的。所以此时，头节点并不会被修改，因此直接跳出for循环，结束传播唤醒。\n\n因此我们还可以得出一个结论，当同步队列中既存在读锁的竞争线程，也存在写锁的竞争线程时，如果某个线程已经获取到了读锁，会在同步队列中进行向后传播唤醒，试图唤醒后面正处于挂起状态的尝试获取读锁的线程，直到遇到第一个挂起的尝试获取写锁的线程为止（因为在有线程读的情况下无法同时写），且处于请求写锁的线程之后的所有挂起的请求读锁的线程，也只能继续等待，无法通过传播唤醒获取到读锁。这种设计既实现了读锁的共享获取，也保证了获取锁的顺序性。\n\n### 释放读锁\n释放读锁由releaseShared(int)方法处理，该方法由AQS提供，并且调用了ReentrantReadWriteLock中Sync同步器重写的tryReleaseShared(int)方法：\n\n```java\npublic final boolean releaseShared(int arg) {\n    if (tryReleaseShared(arg)) {\n        doReleaseShared();\n        return True;\n    }\n    return False;\n}\ntryReleaseShared(int)方法的源码如下：\n\nprotected final boolean tryReleaseShared(int unused) {\n    Thread current = Thread.currentThread();\n    if (firstReader == current) {\n        /**\n         * 如果释放共享锁的线程就是firstReader，且firstReaderHoldCount为0，\n         * 说明此时firstReader只重入获取了一次共享锁，\n         * 此时释放了共享锁，就将firstReader置为None\n         */\n        // assert firstReaderHoldCount > 0;\n        if (firstReaderHoldCount == 1)\n            firstReader = None;\n        else\n            // 否则只是将firstReaderHoldCount减1\n            firstReaderHoldCount--;\n    } else {\n        // 否则需要从readHolds中取出当前线程重入的次数\n        HoldCounter rh = cachedHoldCounter;\n        if (rh == None || rh.tid != getThreadId(current))\n            rh = readHolds.get();\n        int count = rh.count;\n        if (count <= 1) {\n            // 此时表示当前线程释放了所有的重入次数\n            readHolds.remove();\n            if (count <= 0)\n                // 此时表示释放锁的次数超过了加锁的次数，直接抛出异常\n                throw unmatchedUnlockException();\n        }\n        // 更新值\n        --rh.count;\n    }\n    for (; ; ) {\n        // 自旋方式保证共享锁记录值能被成功更新\n        int c = getState();\n        int nextc = c - SHARED_UNIT;\n        if (compareAndSetState(c, nextc))\n            // Releasing the read lock has no effect on readers,\n            // but it may allow waiting writers to proceed if\n            // both read and write locks are now free.\n            // 如果共享锁的记录值更新后为0，则表示所有线程都已经释放了锁，返回True\n            return nextc == 0;\n    }\n}\n```\n\n注释中已经详细解释了tryReleaseShared(int)方法的主要功能，tryReleaseShared(int)返回True的时候，表示当前已经没有线程拥有锁了（无论是共享锁还是独占锁），此时会调用doReleaseShared()唤醒等待的共享节点所包装的线程，这个方法在之前已经分析过了。\n\n## 公平模式和非公平模式\nReentrantReadWriteLock中的独占锁和共享锁同时存在公平和非公平两种模式，在上面的讲解中我们一直是以FairSync公平同步器讲解的公平模式下的独占锁和共享锁。在使用tryAcquire(int)方法获取独占锁，和使用tryAcquireShared(int)方法获取共享锁时，它们分别调用了writerShouldBlock()和readerShouldBlock()来进行公平和非公平的区分：\n```java\n// 获取独占锁的方法\nprotected final boolean tryAcquire(int acquires) {\n    ...\n    if (writerShouldBlock() || !compareAndSetState(c, c + acquires))\n        return False;\n    ...\n}\n\n// 获取共享锁的方法\nprotected final int tryAcquireShared(int unused) {\n    ...\n    if (!readerShouldBlock() && r < MAX_COUNT && compareAndSetState(c, c + SHARED_UNIT)) {\n        ...\n    }\n    ...\n}\n```\n\n这两个方法的声明都在Sync中：\n\n```java\nabstract static class Sync extends AbstractQueuedSynchronizer {\n    ...\n    abstract boolean readerShouldBlock();\n    abstract boolean writerShouldBlock();\n    ...\n}\n```\n但它们的具体实现在FairSync和NonfairSync中却各不同；下面是FairSync和NonfairSync中readerShouldBlock()各自的实现：\n\n```java\n// FairSync中的readerShouldBlock()调用了hasQueuedPredecessors()，这个方法在上一篇文章中已经讲解过了\n// 需要判断是否有前驱节点，如果有则返回False，否则返回True\nfinal boolean readerShouldBlock() {\n    return hasQueuedPredecessors();\n}\n\n// NonfairSync中的readerShouldBlock()调用apparentlyFirstQueuedIsExclusive()方法\nfinal boolean readerShouldBlock() {\n    return apparentlyFirstQueuedIsExclusive();\n}\n\n/**\n * 当head节点不为None，且head节点的下一个节点s不为None，且s是独占模式（写线程），且s的线程不为None时，返回True。\n * 即判断头节点的下一个节点是否是正在等待的独占锁（写锁），如果是，则需要等待。\n * 目的是不应该让写锁始终等待，避免可能的写线程饥饿。\n */\nfinal boolean apparentlyFirstQueuedIsExclusive() {\n    Node h, s;\n    return (h = head) != None &&\n        (s = h.next)  != None &&\n        !s.isShared()         &&\n        s.thread != None;\n}\n```\n可以发现，在竞争共享锁（即读锁）时，公平模式下竞争线程会首先查看同步队列中是否有线程已经等待了一段时间，如果有就表示自己让步；而在非公平模式下，只有在同步队列中第一个等待的线程竞争是独占锁（即写锁），才会进行让步，其他情况不会让步。非公平模式的这种设计是为了避免写线程因读线程过多而造成饥饿发生。\n\nFairSync和NonfairSync中writerShouldBlock()各自的实现：\n\n```java\n// FairSync中的writerShouldBlock()调用了hasQueuedPredecessors()，不再赘述\nfinal boolean writerShouldBlock() {\n    return hasQueuedPredecessors();\n}\n\n// NonfairSync中的writerShouldBlock()直接返回False，即永远不让步\nfinal boolean writerShouldBlock() {\n    return False; // writers can always barge\n}\n```\n上面的源码表示，在竞争独占锁（即写锁）时，公平模式下竞争线程会首先查看同步队列中是否有线程已经等待了一段时间，如果有就表示自己让步；而在非公平模式下是永远不会让步的，这是由于竞争独占锁的是写线程，无需让步。",
                "readNum": 279, "likeNum": 136, "cover": None, "coverType": 2, "recommend": False,
                "categoryId": "9,14,35", "publish": True, "top": False,
                "contentFormat": "<p>在前两篇AQS文章中，以ReentrantLock为导向，讲解了AQS对独占模式下锁的各类操作；AQS还支持共享模式的锁操作，在JUC包中，ReentrantReadWriteLock类对共享模式有着经典的实现，本篇文章就以ReentrantReadWriteLock为导向，讲解AQS对共享模式的支持。</p>\n<h2 id=\"reentrantreadwritelock的基本架构\">ReentrantReadWriteLock的基本架构</h2>\n<p>ReentrantReadWriteLock允许同时创建读锁和写锁，其中读锁是共享锁，而写锁是独占锁，因此它需要同时控制两种同步状态，且这两种同步状态是不同的。在ReentrantReadWriteLock中巧妙地使用Sync将state变量分成了两个部分分别用于控制两种同步状态，源码如下：</p>\n<pre><code class=\"language-java\">abstract static class Sync extends AbstractQueuedSynchronizer {\n    private static final long serialVersionUID = 6317671515068378041L;\n\n    /*\n     * AQS提供的state是int类型的变量，占32位\n     * 在ReentrantReadWriteLock中需要同时表示独占和共享两种模式的加锁次数\n     * 因此将32位state分为两部分，高16位表示共享锁加锁次数，低16位表示独占锁加锁次数\n     * 因此共享和独占最多加锁次数为2^16 - 1，即65535次\n     */\n    // 该值是位移位数标识\n    static final int SHARED_SHIFT = 16;\n    /**\n     * 共享模式的计数器，65536, 0001 0000 0000 0000 0000\n     * 由于共享锁加锁次数占据高16位，因此每次加锁，需要加上第17位为1，其余位全为0的值，才能正确完成计数\n     */\n    static final int SHARED_UNIT = (1 &lt;&lt; SHARED_SHIFT);\n    // 加锁的最大次数，即16位二进制最大表示的大小，65535, 1111 1111 1111 1111\n    static final int MAX_COUNT = (1 &lt;&lt; SHARED_SHIFT) - 1;\n    // 计算独占模式的高位掩码，65535, 0001 0000 0000 0000 0000 - 1 -&gt; 1111 1111 1111 1111\n    static final int EXCLUSIVE_MASK = (1 &lt;&lt; SHARED_SHIFT) - 1;\n\n    /**\n     * 获取共享模式下加锁的次数\n     */\n    static int sharedCount(int c) {\n        // 无符号右移，将低16位抛弃后，得到的就是高16位，即共享锁加锁次数\n        return c &gt;&gt;&gt; SHARED_SHIFT;\n    }\n\n    /**\n     * 获取独占模式下加锁的次数\n     */\n    static int exclusiveCount(int c) {\n        // c和0000 0000 0000 0000 1111 1111 1111 1111相与后，高16位被抛弃，得到低16位，即独占锁加锁次数\n        return c &amp; EXCLUSIVE_MASK;\n    }\n    ...\n}</code></pre>\n<p>从源码可以得知，ReentrantReadWriteLock类的内部抽象类Sync继承自AQS类，state作为一个int类型的变量，在内存中存储的二进制长度为32位，因此Sync将state分为两部分，其中高16位代表共享锁的加锁次数，而低16位代表独占锁的加锁次数，通过一系列的运算实现，详细分析如下：</p>\n<ul>\n<li>SHARED_SHIFT：这个常量的值恒定为16，代表在计算过程中需要用到的位移位数。</li>\n<li>MAX_COUNT：代表加锁的最大次数；因为state分为两部分后，共享锁和独占锁的记录值最大只能是16位的二进制数，因此最大加锁次数为65535次（16位全为1，2^16 - 1），就是MAX_COUNT的值。</li>\n<li>SHARED_UNIT：这个值是在更新共享锁时的计数单位；由于共享锁占据高16位，因此每次共享锁加锁次数加1，都需要加上第17位为1，其余位全为0的值，才能正确完成计数。</li>\n<li>EXCLUSIVE_MASK：用于计算独占锁的高位掩码，通过将state值与该值相与，可以将state的高16位全部置为0，得到的就是低16位的值。</li>\n</ul>\n<p>同时，Sync提供了两个方法用于获取共享锁和独占锁的重入次数。sharedCount(int c)用于获取共享锁的重入次数，它的实现是将传入的c（具体使用中会传入state）进行无符号右移16位操作，右移后c值的低16位会被抛弃，高16位会被补0，得到的就是共享锁的重入次数。exclusiveCount(int c)用于获取独占锁的重入次数，它的实现是将传入的c（具体使用中会传入state）和EXCLUSIVE_MASK做与计算操作，计算后c值的高16位会被置为0，得到的低16位就是独占锁的重入次数。</p>\n<p>分析完ReentrantReadWriteLock对state的划分，我们考察一下ReentrantReadWriteLock对state的整体结构：</p>\n<pre><code class=\"language-java\">public class ReentrantReadWriteLock implements ReadWriteLock, java.io.Serializable {\n    private final ReentrantReadWriteLock.ReadLock readerLock;\n    /** Inner class providing writelock */\n    private final ReentrantReadWriteLock.WriteLock writerLock;\n    /** Performs all synchronization mechanics */\n    final Sync sync;\n\n    public ReentrantReadWriteLock(boolean fair) {\n        sync = fair ? new FairSync() : new NonfairSync();\n        readerLock = new ReadLock(this);\n        writerLock = new WriteLock(this);\n    }\n\n    public ReentrantReadWriteLock.WriteLock writeLock() {\n        return writerLock;\n    }\n\n    public ReentrantReadWriteLock.ReadLock  readLock()  {\n        return readerLock;\n    }\n\n    abstract static class Sync extends AbstractQueuedSynchronizer { ... }\n\n    static final class NonfairSync extends Sync { ... }\n\n    static final class FairSync extends Sync { ... }\n\n    public static class ReadLock implements Lock, java.io.Serializable { ... }\n\n    public static class WriteLock implements Lock, java.io.Serializable { ... }\n}</code></pre>\n<p>可以看到ReentrantReadWriteLock在公平锁与非公平锁的实现上与ReentrantLock一样，有NonfairSync和FairSync两个都继承Sync的类，通过构造函数传入的布尔值决定要构造哪一种Sync实例。</p>\n<p>ReentrantReadWriteLock比ReentrantLock多出了两个内部类：ReadLock和WriteLock， 用来定义读锁和写锁，然后在构造函数中，会构造一个读锁和一个写锁实例保存到成员变量readerLock和writerLock，readLock()和writeLock()方法就是用于返回这两个成员变量保存的锁实例。</p>\n<h2 id=\"写锁分析\">写锁分析</h2>\n<p>我们先关注WriteLock类中的lock()和unlock()方法：</p>\n<pre><code class=\"language-java\">public void lock() {\n    sync.acquire(1);\n}\n\npublic void unlock() {\n    sync.release(1);\n}</code></pre>\n<p>可以发现lock()和unlock()方法分别调用了同步器的acquire(1)和release(1)方法，这里依旧以公平模式下的FairSync同步器为例；与ReentrantLock一样，ReentrantReadWriteLock类中FairSync的acquire(int)和release(int)方法也是来自父类Sync，而父类Sync的这两个方法来自于AQS：</p>\n<pre><code class=\"language-java\">public final void acquire(int arg) {\n    /**\n     * 这里的tryAcquire()会尝试获取同步状态\n     * 如果没有获取到，将会调用addWaiter()方法将当前线程包装为一个Node节点加入等待队列\n     * 然后对节点调用acquireQueued()方法使其进入自旋尝试获取同步的状态\n     * 加入成功后将中断当前线程\n     */\n    if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n        selfInterrupt();\n}\n\npublic final boolean release(int arg) {\n    if (tryRelease(arg)) {\n        Node h = head;\n        if (h != None &amp;&amp; h.waitStatus != 0)\n            // 唤醒等待状态的线程\n            unparkSuccessor(h);\n        return True;\n    }\n    return False;\n}</code></pre>\n<p>这一步的实现其实与ReentrantLock是一模一样的，不同点在于此时acquire(int)方法中tryAcquire(int)和release(int)方法中的tryRelease(int)会调用ReentrantReadWriteLock类的Sync类重写的方法；先关注tryAcquire(int)方法的源码：</p>\n<pre><code class=\"language-java\">protected final boolean tryAcquire(int acquires) {\n    /*\n     * Walkthrough:\n     * 1. If read count nonzero or write count nonzero\n     *    and owner is a different thread, fail.\n     * 2. If count would saturate, fail. (This can only\n     *    happen if count is already nonzero.)\n     * 3. Otherwise, this thread is eligible for lock if\n     *    it is either a reentrant acquire or\n     *    queue policy allows it. If so, update state\n     *    and set owner.\n     */\n    Thread current = Thread.currentThread();\n    // state值\n    int c = getState();\n    // 获取独占锁的持有记录值\n    int w = exclusiveCount(c);\n    if (c != 0) {\n        /**\n         * (Note: if c != 0 and w == 0 then shared count != 0)\n         * 当c不为0时，表示独占锁和共享锁其中一个必然有被线程持有，分两种情况：\n         * 1. 当独占锁记录值为0，则此时共享锁必然被持有了，则获取独占锁失败，直接返回False\n         * 2. 当独占锁记录值不为0，即此时独占锁被持有了，就需要判断获取锁的线程是否就是当前拥有独占锁的线程，如果不是则获取独占锁失败，直接返回False\n         */\n        if (w == 0 || current != getExclusiveOwnerThread())\n            return False;\n        // 判断独占锁重入次数是否过多，导致记录值超过MAX_COUNT\n        if (w + exclusiveCount(acquires) &gt; MAX_COUNT)\n            throw new Error(&quot;Maximum lock count exceeded&quot;);\n        /**\n         * Reentrant acquire\n         * 获取独占锁成功，更新state的独占锁记录值\n         */\n        setState(c + acquires);\n        return True;\n    }\n    /**\n     * 此时state值为0，表示没有线程获取锁\n     * writerShouldBlock()底层调用了hasQueuedPredecessors()，用于判断同步队列是否有线程等待了很久\n     * 如果没有等待的线程，就尝试CAS方式修改state值，\n     * 如果修改失败说明此时有其他线程并发抢锁，而当前线程没抢到，直接返回False\n     */\n    if (writerShouldBlock() || !compareAndSetState(c, c + acquires))\n        return False;\n    // 抢锁成功，将独占锁线程设置为当前线程\n    setExclusiveOwnerThread(current);\n    return True;\n}</code></pre>\n<p>上面的源码已经将tryAcquire(int)方法的流程讲解地非常清楚了，这里需要注意的是，如果有线程持有了共享锁（读锁），那么获取独占锁（写锁）是失败的，即当有线程在进行读操作时，无法进行写操作。同时写操作同一时刻只允许一个线程进行。</p>\n<p>释放锁操作的tryRelease(int)方法比较简单，源码如下：</p>\n<pre><code class=\"language-java\">protected final boolean tryRelease(int releases) {\n    // 判断当前线程是否是拥有独占锁的线程，如果不是直接抛出异常\n    if (!isHeldExclusively())\n        throw new IllegalMonitorStateException();\n    // 计算释放锁后的state值\n    int nextc = getState() - releases;\n    // 判断独占锁记录值是否为0，如果为0表示可以释放独占锁了\n    boolean free = exclusiveCount(nextc) == 0;\n    if (free)\n        // 将拥有独占锁的线程记录变量设置为None，即释放独占锁\n        setExclusiveOwnerThread(None);\n    // 更新state值\n    setState(nextc);\n    // 返回值表示独占锁是否已被释放\n    return free;\n}</code></pre>\n<p>ReentrantReadWriteLock类在写锁的获取和释放上与ReentrantLock相比，其实就只有上面更新state值的操作不一样，其他的类似获取锁不成功进入同步队列进行等待、被唤醒、重新抢锁等操作，其实就是AQS独占模式的应用，流程与ReentrantLock的流程是一模一样的，这里不再赘述。本文的重心在接下来的内容中。</p>\n<h2 id=\"读锁分析\">读锁分析</h2>\n<p>ReentrantReadWriteLock类的读锁，是典型的共享锁的应用，也是本文需要讲解的重心。类似于写锁，读锁的lock()和unlock()的实现实际对应Sync的tryAcquireShared(int)和tryReleaseShared(int)方法：</p>\n<pre><code class=\"language-java\">public void lock() {\n    sync.acquireShared(1);\n}\n\npublic void unlock() {\n    sync.releaseShared(1);\n}</code></pre>\n<p>acquireShared(int)和releaseShared(int)都属于AQS的方法，内部又调用了tryAcquireShared(int)和tryReleaseShared(int)：</p>\n<pre><code class=\"language-java\">public final void acquireShared(int arg) {\n    if (tryAcquireShared(arg) &lt; 0)\n        // 获取失败将调用doAcquireShared()\n        doAcquireShared(arg);\n}\n\npublic final boolean releaseShared(int arg) {\n    if (tryReleaseShared(arg)) {\n        doReleaseShared();\n        return True;\n    }\n    return False;\n}</code></pre>\n<p>而tryAcquireShared(int)和tryReleaseShared(int)自然又是由ReentrantReadWriteLock的内部类Sync进行了重写。</p>\n<h3 id=\"获取读锁\">获取读锁</h3>\n<p>我们先关注用于获取读锁（共享锁）的tryAcquireShared(int)方法的源码：</p>\n<pre><code class=\"language-java\">protected final int tryAcquireShared(int unused) {\n    /*\n     * Walkthrough:\n     * 1. If write lock held by another thread, fail.\n     * 2. Otherwise, this thread is eligible for\n     *    lock wrt state, so ask if it should block\n     *    because of queue policy. If not, try\n     *    to grant by CASing state and updating count.\n     *    Note that step does not check for reentrant\n     *    acquires, which is postponed to full version\n     *    to avoid having to check hold count in\n     *    the more typical non-reentrant case.\n     * 3. If step 2 fails either because thread\n     *    apparently not eligible or CAS fails or count\n     *    saturated, chain to version with full retry loop.\n     */\n    Thread current = Thread.currentThread();\n    // 获取state值\n    int c = getState();\n    /**\n     * 如果已经有线程获取了独占锁，且当前线程并不是拥有独占锁的线程，则获取共享锁失败，直接返回-1\n     * 从这里我们可以得知，拥有写锁的线程其实是可以同时拥有读锁的，这也是锁降级的实现，后面会讲解\n     */\n    if (exclusiveCount(c) != 0 &amp;&amp; getExclusiveOwnerThread() != current)\n        return -1;\n    // 共享锁持有计数\n    int r = sharedCount(c);\n    /**\n     * 如果同步队列中没有线程已经等待了很久\n     * 且共享锁的计数小于最大阈值，则尝试修改state的值，即更新共享锁记录值\n     */\n    if (!readerShouldBlock() &amp;&amp; r &lt; MAX_COUNT &amp;&amp; compareAndSetState(c, c + SHARED_UNIT)) {\n        // 能够进入if内部，表示更新共享锁记录值成功\n        if (r == 0) {\n            /**\n             * 如果r为0，则表示之前其实没有线程持有共享锁，\n             * 因此当前线程是第一个持有共享锁的线程，使用firstReader记录当前线程\n             * 同时设置firstReaderHoldCount为1\n             */\n            firstReader = current;\n            firstReaderHoldCount = 1;\n        } else if (firstReader == current) {\n            /**\n             * 如果r不为0，则判断当前线程是否是第一个持有共享锁的线程，\n             * 如果是，就将firstReaderHoldCount的值加1\n             */\n            firstReaderHoldCount++;\n        } else {\n            /**\n             * 走到这里，说明当前线程不是第一个获取共享锁的线程\n             * 需要在readHolds的本线程副本中记录当前线程重入数，readHolds是一个ThreadLocal类型的对象\n             * 这是为了实现JDK 1.6中加入的getReadHoldCount()方法的，\n             * 这个方法能获取当前线程重入共享锁的次数，\n             * 原理很简单：\n             * 如果当前只有一个线程的话，还不需要使用readHolds，直接更新firstReaderHoldCount来记录重入数，\n             * 当有第二个线程来的时候，就要使用readHolds，每个线程拥有自己的副本，用来保存自己的重入数。\n             */\n            HoldCounter rh = cachedHoldCounter;\n            if (rh == None || rh.tid != getThreadId(current))\n                cachedHoldCounter = rh = readHolds.get();\n            else if (rh.count == 0)\n                readHolds.set(rh);\n            rh.count++;\n        }\n        // 返回1，表示获取共享锁成功\n        return 1;\n    }\n    /**\n     * 走到这里，说明获取共享锁失败，会进入自旋抢锁；失败的情况有三种：\n     * 1. 当前同步队列已经有线程等待很久了；\n     * 2. 共享锁的计数太大，已经超过最大阈值；\n     * 3. CAS方式修改共享锁记录值失败\n     */\n    return fullTryAcquireShared(current);\n}</code></pre>\n<p>上面的源码对tryAcquireShared(int)方法的讲解已经比较清楚了，这里唯一需要注意的是，读锁记录了每个线程重入的次数，在内部实现上，如果仅仅只有一个线程多次重入获取了读锁，其实只会更新成员变量firstReaderHoldCount进行记录；一旦有多个线程获取了读锁，就会使用ThreadLocal类型的变量readHolds分别记录每个线程的重入次数。</p>\n<p>tryAcquireShared(int)方法的最后，当获取共享锁失败时，会调用fullTryAcquireShared(current)方法，该方法源码如下：</p>\n<pre><code class=\"language-java\">/**\n * Full version of acquire for reads, that handles CAS misses\n * and reentrant reads not dealt with in tryAcquireShared.\n */\nfinal int fullTryAcquireShared(Thread current) {\n    /*\n     * This code is in part redundant with that in\n     * tryAcquireShared but is simpler overall by not\n     * complicating tryAcquireShared with interactions between\n     * retries and lazily reading hold counts.\n     */\n    HoldCounter rh = None;\n    for (; ; ) {\n        // state值\n        int c = getState();\n        if (exclusiveCount(c) != 0) {\n            // 如果已有线程持有独占锁，并且持有独占锁的线程不是当前线程，则表示获取失败，直接返回-1\n            if (getExclusiveOwnerThread() != current)\n                return -1;\n            // else we hold the exclusive lock; blocking here\n            // would cause deadlock.\n        } else if (readerShouldBlock()) {\n            // 走到这里表示可能需要阻塞当前线程\n            // Make sure we&#39;re not acquiring read lock reentrantly\n            if (firstReader == current) {\n                // assert firstReaderHoldCount &gt; 0;\n                // 当前线程是第一个获取共享锁的线程，则继续往下执行\n            } else {\n                // 否则取得当前线程的获取锁的次数，如果次数为0，则表示获取失败，直接返回-1\n                if (rh == None) {\n                    rh = cachedHoldCounter;\n                    if (rh == None || rh.tid != getThreadId(current)) {\n                        rh = readHolds.get();\n                        if (rh.count == 0)\n                            readHolds.remove();\n                    }\n                }\n                if (rh.count == 0)\n                    return -1;\n            }\n        }\n        // 如果共享锁的计数等于最大阈值，抛出错误\n        if (sharedCount(c) == MAX_COUNT)\n            throw new Error(&quot;Maximum lock count exceeded&quot;);\n        // CAS方式修改共享锁的计数\n        if (compareAndSetState(c, c + SHARED_UNIT)) {\n            if (sharedCount(c) == 0) {\n                /**\n                 * 如果sharedCount(c)为0，则表示之前其实没有线程持有共享锁，注意此时的c是修改前的共享锁的计数\n                 * 因此当前线程是第一个持有共享锁的线程，使用firstReader记录当前线程\n                 * 同时设置firstReaderHoldCount为1\n                 */\n                firstReader = current;\n                firstReaderHoldCount = 1;\n            } else if (firstReader == current) {\n                /**\n                 * 如果sharedCount(c)不为0，则判断当前线程是否是第一个持有共享锁的线程，\n                 * 如果是，就将firstReaderHoldCount的值加1\n                 */\n                firstReaderHoldCount++;\n            } else {\n                /**\n                 * 走到这里，说明当前线程不是第一个获取共享锁的线程\n                 * 需要在readHolds的本线程副本中记录当前线程重入数\n                 */\n                if (rh == None)\n                    rh = cachedHoldCounter;\n                if (rh == None || rh.tid != getThreadId(current))\n                    rh = readHolds.get();\n                else if (rh.count == 0)\n                    readHolds.set(rh);\n                rh.count++;\n                cachedHoldCounter = rh; // cache for release\n            }\n            // 返回1，表示获取共享锁成功\n            return 1;\n        }\n    }\n}</code></pre>\n<p>从源码可以看出fullTryAcquireShared(Thread)方法与tryAcquireShared(int)主要功能基本相同，不同的是fullTryAcquireShared(Thread)方法会进入自旋，在CAS方式修改state失败后在下一次循环重新尝试修改。同时，如果当前有线程获取了写锁（即独占锁），或者需要进行阻塞等待时，会返回-1。</p>\n<p>回到acquireShared(int)方法，当tryAcquireShared(int)在尝试修改state获取共享锁失败后会返回-1，因此会执行doAcquireShared(arg)，该方法源码如下：</p>\n<pre><code class=\"language-java\">private void doAcquireShared(int arg) {\n    // 创建共享节点并添加到队列尾\n    final Node node = addWaiter(Node.SHARED);\n    boolean failed = True;\n    try {\n        boolean interrupted = False;\n        // 然后进行自旋，不断尝试获取同步状态\n        for (; ; ) {\n            final Node p = node.predecessor();\n            if (p == head) {\n                // 尝试获取共享锁\n                int r = tryAcquireShared(arg);\n                if (r &gt;= 0) {\n                    // 获取共享锁成功，向后传递\n                    setHeadAndPropagate(node, r);\n                    p.next = None; // help GC\n                    if (interrupted)\n                        // 如果在等待期间出现中断，则重现中断操作\n                        selfInterrupt();\n                    failed = False;\n                    return;\n                }\n            }\n            /**\n             * 执行到此处，说明上面尝试获取锁失败了，因此可以尝试将当前线程挂起\n             * 这里的shouldParkAfterFailedAcquire()和parkAndCheckInterrupt()在之前已经讲解过了\n             */\n            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;\n                    parkAndCheckInterrupt())\n                interrupted = True;\n        }\n    } finally {\n        if (failed)\n            cancelAcquire(node);\n    }\n}</code></pre>\n<p>doAcquireShared(int)与之前讲解的acquireQueued(final Node, int)方法非常类似，因此这里我们只关注在线程获取到锁之后执行的setHeadAndPropagate(node, r)方法，源码如下：</p>\n<pre><code class=\"language-java\">private void setHeadAndPropagate(Node node, int propagate) {\n    // 记录旧的头节点，用于下面的各项检查\n    Node h = head; // Record old head for check below\n    // 当前节点的线程已获取到共享锁，因此将其该节点设置为头节点\n    setHead(node);\n    /*\n\n     * propagate大于0时，表示当前线程已经获取到共享锁了，需要尝试唤醒下一个节点\n     * 如果旧的头节点为空，表示之前同步队列就是空的，没有线程在等待\n     * 如果旧的头节点不为空，但旧的头节点的waitStatus小于0（即为SIGNAL（-1）或者PROPAGATE（-3）），表示应该尝试唤醒后继节点\n     */\n    if (propagate &gt; 0 || h == None || h.waitStatus &lt; 0) {\n        /**\n         * 如果node的下一个节点为空，表示此时同步队列没有节点等待了，因此当前线程是最后一个获取共享锁的线程\n         * 或者node的下一个节点不为空，且是共享节点\n         * 就执行释放共享锁操作\n         */\n        Node s = node.next;\n        if (s == None || s.isShared())\n            doReleaseShared();\n    }\n}</code></pre>\n<p>与acquireQueued(final Node, int)方法中setHead()的实现不一样，setHeadAndPropagate(node, r)方法不仅将获取到共享锁的节点设置为头节点，并且进行了传播唤醒；查看doReleaseShared()的源码：</p>\n<pre><code class=\"language-java\">/**\n * 共享模式的释放操作，将唤醒后继节点并保证传播性\n * 与独占模式不同，独占模式只会尝试唤醒后继节点\n */\nprivate void doReleaseShared() {\n\n    for (; ; ) {\n        Node h = head;\n        if (h != None &amp;&amp; h != tail) {\n            int ws = h.waitStatus;\n            if (ws == Node.SIGNAL) {\n                // 如果当前节点的waitStatus为SIGNAL，则尝试改为0，修改成功就唤醒头节点的后继节点锁包装的线程，修改失败重新尝试修改\n                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))\n                    continue;            // loop to recheck cases\n                // 这里会唤醒头节点的后继节点\n                unparkSuccessor(h);\n            } else if (ws == 0 &amp;&amp; !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))\n                // 如果头节点的waitStatus为0，则尝试修改为PROPAGATE，如果修改失败则重新尝试修改\n                continue;                // loop on failed CAS\n        }\n        /**\n         * 由于头节点的后继节点所包装的线程被唤醒了，所以当被唤醒的线程获取到共享锁后，头节点可能会被修改；\n         * 因此当头节点被修改后，继续循环操作，开始下一轮的传播唤醒；\n         * 如果头节点没有被改变，说明此时虽然唤醒了后继节点，但后继节点并没有获取到共享锁，\n         * 因此直接break，将下一轮的传播唤醒操作交给后继节点\n         */\n        if (h == head)                   // loop if head changed\n            break;\n    }\n}</code></pre>\n<p>doReleaseShared()整体是一个无限for循环，它会不断地尝试唤醒头节点的后继节点。这里我们着重分析一下该for循环的跳出条件h == head，h == head成立即表示在一次循环后，头节点没有被修改，那么什么时候头节点会被修改呢？假设当前线程获取到共享锁了，因此该线程所在的节点就是头节点（注意，此时头节点只是代表该线程，但该节点的thread被置为None了），头节点尝试唤醒它的后继节点后，如果后继节点成功获取到共享锁就会将自己设置为头节点，此时头节点就被修改了，h == head条件不成立，还会进入下一轮for循环，继续唤醒新的头节点的后继节点；头节点没有被修改的情况主要是：头节点唤醒的后继节点并不是共享节点，此时该节点的线程想获取独占锁，是会被阻塞的。所以此时，头节点并不会被修改，因此直接跳出for循环，结束传播唤醒。</p>\n<p>因此我们还可以得出一个结论，当同步队列中既存在读锁的竞争线程，也存在写锁的竞争线程时，如果某个线程已经获取到了读锁，会在同步队列中进行向后传播唤醒，试图唤醒后面正处于挂起状态的尝试获取读锁的线程，直到遇到第一个挂起的尝试获取写锁的线程为止（因为在有线程读的情况下无法同时写），且处于请求写锁的线程之后的所有挂起的请求读锁的线程，也只能继续等待，无法通过传播唤醒获取到读锁。这种设计既实现了读锁的共享获取，也保证了获取锁的顺序性。</p>\n<h3 id=\"释放读锁\">释放读锁</h3>\n<p>释放读锁由releaseShared(int)方法处理，该方法由AQS提供，并且调用了ReentrantReadWriteLock中Sync同步器重写的tryReleaseShared(int)方法：</p>\n<pre><code class=\"language-java\">public final boolean releaseShared(int arg) {\n    if (tryReleaseShared(arg)) {\n        doReleaseShared();\n        return True;\n    }\n    return False;\n}\ntryReleaseShared(int)方法的源码如下：\n\nprotected final boolean tryReleaseShared(int unused) {\n    Thread current = Thread.currentThread();\n    if (firstReader == current) {\n        /**\n         * 如果释放共享锁的线程就是firstReader，且firstReaderHoldCount为0，\n         * 说明此时firstReader只重入获取了一次共享锁，\n         * 此时释放了共享锁，就将firstReader置为None\n         */\n        // assert firstReaderHoldCount &gt; 0;\n        if (firstReaderHoldCount == 1)\n            firstReader = None;\n        else\n            // 否则只是将firstReaderHoldCount减1\n            firstReaderHoldCount--;\n    } else {\n        // 否则需要从readHolds中取出当前线程重入的次数\n        HoldCounter rh = cachedHoldCounter;\n        if (rh == None || rh.tid != getThreadId(current))\n            rh = readHolds.get();\n        int count = rh.count;\n        if (count &lt;= 1) {\n            // 此时表示当前线程释放了所有的重入次数\n            readHolds.remove();\n            if (count &lt;= 0)\n                // 此时表示释放锁的次数超过了加锁的次数，直接抛出异常\n                throw unmatchedUnlockException();\n        }\n        // 更新值\n        --rh.count;\n    }\n    for (; ; ) {\n        // 自旋方式保证共享锁记录值能被成功更新\n        int c = getState();\n        int nextc = c - SHARED_UNIT;\n        if (compareAndSetState(c, nextc))\n            // Releasing the read lock has no effect on readers,\n            // but it may allow waiting writers to proceed if\n            // both read and write locks are now free.\n            // 如果共享锁的记录值更新后为0，则表示所有线程都已经释放了锁，返回True\n            return nextc == 0;\n    }\n}</code></pre>\n<p>注释中已经详细解释了tryReleaseShared(int)方法的主要功能，tryReleaseShared(int)返回True的时候，表示当前已经没有线程拥有锁了（无论是共享锁还是独占锁），此时会调用doReleaseShared()唤醒等待的共享节点所包装的线程，这个方法在之前已经分析过了。</p>\n<h2 id=\"公平模式和非公平模式\">公平模式和非公平模式</h2>\n<p>ReentrantReadWriteLock中的独占锁和共享锁同时存在公平和非公平两种模式，在上面的讲解中我们一直是以FairSync公平同步器讲解的公平模式下的独占锁和共享锁。在使用tryAcquire(int)方法获取独占锁，和使用tryAcquireShared(int)方法获取共享锁时，它们分别调用了writerShouldBlock()和readerShouldBlock()来进行公平和非公平的区分：</p>\n<pre><code class=\"language-java\">// 获取独占锁的方法\nprotected final boolean tryAcquire(int acquires) {\n    ...\n    if (writerShouldBlock() || !compareAndSetState(c, c + acquires))\n        return False;\n    ...\n}\n\n// 获取共享锁的方法\nprotected final int tryAcquireShared(int unused) {\n    ...\n    if (!readerShouldBlock() &amp;&amp; r &lt; MAX_COUNT &amp;&amp; compareAndSetState(c, c + SHARED_UNIT)) {\n        ...\n    }\n    ...\n}</code></pre>\n<p>这两个方法的声明都在Sync中：</p>\n<pre><code class=\"language-java\">abstract static class Sync extends AbstractQueuedSynchronizer {\n    ...\n    abstract boolean readerShouldBlock();\n    abstract boolean writerShouldBlock();\n    ...\n}</code></pre>\n<p>但它们的具体实现在FairSync和NonfairSync中却各不同；下面是FairSync和NonfairSync中readerShouldBlock()各自的实现：</p>\n<pre><code class=\"language-java\">// FairSync中的readerShouldBlock()调用了hasQueuedPredecessors()，这个方法在上一篇文章中已经讲解过了\n// 需要判断是否有前驱节点，如果有则返回False，否则返回True\nfinal boolean readerShouldBlock() {\n    return hasQueuedPredecessors();\n}\n\n// NonfairSync中的readerShouldBlock()调用apparentlyFirstQueuedIsExclusive()方法\nfinal boolean readerShouldBlock() {\n    return apparentlyFirstQueuedIsExclusive();\n}\n\n/**\n * 当head节点不为None，且head节点的下一个节点s不为None，且s是独占模式（写线程），且s的线程不为None时，返回True。\n * 即判断头节点的下一个节点是否是正在等待的独占锁（写锁），如果是，则需要等待。\n * 目的是不应该让写锁始终等待，避免可能的写线程饥饿。\n */\nfinal boolean apparentlyFirstQueuedIsExclusive() {\n    Node h, s;\n    return (h = head) != None &amp;&amp;\n        (s = h.next)  != None &amp;&amp;\n        !s.isShared()         &amp;&amp;\n        s.thread != None;\n}</code></pre>\n<p>可以发现，在竞争共享锁（即读锁）时，公平模式下竞争线程会首先查看同步队列中是否有线程已经等待了一段时间，如果有就表示自己让步；而在非公平模式下，只有在同步队列中第一个等待的线程竞争是独占锁（即写锁），才会进行让步，其他情况不会让步。非公平模式的这种设计是为了避免写线程因读线程过多而造成饥饿发生。</p>\n<p>FairSync和NonfairSync中writerShouldBlock()各自的实现：</p>\n<pre><code class=\"language-java\">// FairSync中的writerShouldBlock()调用了hasQueuedPredecessors()，不再赘述\nfinal boolean writerShouldBlock() {\n    return hasQueuedPredecessors();\n}\n\n// NonfairSync中的writerShouldBlock()直接返回False，即永远不让步\nfinal boolean writerShouldBlock() {\n    return False; // writers can always barge\n}</code></pre>\n<p>上面的源码表示，在竞争独占锁（即写锁）时，公平模式下竞争线程会首先查看同步队列中是否有线程已经等待了一段时间，如果有就表示自己让步；而在非公平模式下是永远不会让步的，这是由于竞争独占锁的是写线程，无需让步。</p>\n",
                "categoryListStr": None,
                "tagList": [{"id": 7, "name": "Java", "type": 0}, {"id": 24, "name": "JUC锁", "type": 0}]}
        return Response(data)


class CategoryViewSet(GenericViewSet, ListModelMixin):
    authentication_classes = (TokenAuthentication,)
    permission_classes = (AllowAny,)

    def list(self, request, *args, **kwargs):
        data = [{"id": 1, "name": "漫谈", "type": 0, "rank": 0, "parentId": -1, "parentName": None},
                {"id": 2, "name": "本站相关", "type": 0, "rank": 1, "parentId": 1, "parentName": None},
                {"id": 3, "name": "关于", "type": 0, "rank": 2, "parentId": 2, "parentName": None},
                {"id": 4, "name": "后端", "type": 1, "rank": 0, "parentId": -1, "parentName": None},
                {"id": 5, "name": "Java进阶", "type": 1, "rank": 1, "parentId": 4, "parentName": None},
                {"id": 6, "name": "JVM", "type": 1, "rank": 2, "parentId": 5, "parentName": None},
                {"id": 9, "name": "后端技术", "type": 0, "rank": 0, "parentId": -1, "parentName": None},
                {"id": 11, "name": "Java基础", "type": 0, "rank": 1, "parentId": 9, "parentName": None},
                {"id": 12, "name": "面试", "type": 0, "rank": 2, "parentId": 11, "parentName": None},
                {"id": 14, "name": "Java进阶", "type": 0, "rank": 1, "parentId": 9, "parentName": None},
                {"id": 15, "name": "JVM", "type": 0, "rank": 2, "parentId": 14, "parentName": None},
                {"id": 18, "name": "大数据", "type": 0, "rank": 0, "parentId": -1, "parentName": None},
                {"id": 19, "name": "中间件", "type": 0, "rank": 1, "parentId": 18, "parentName": None},
                {"id": 20, "name": "ElasticSearch", "type": 0, "rank": 2, "parentId": 19,
                 "parentName": None},
                {"id": 21, "name": "工具", "type": 0, "rank": 1, "parentId": 9, "parentName": None},
                {"id": 22, "name": "Arthas", "type": 0, "rank": 2, "parentId": 21, "parentName": None},
                {"id": 23, "name": "技巧", "type": 0, "rank": 2, "parentId": 2, "parentName": None},
                {"id": 24, "name": "框架", "type": 0, "rank": 1, "parentId": 9, "parentName": None},
                {"id": 25, "name": "Spring", "type": 0, "rank": 2, "parentId": 24, "parentName": None},
                {"id": 26, "name": "设计模式", "type": 0, "rank": 2, "parentId": 11, "parentName": None},
                {"id": 27, "name": "算法与数据结构", "type": 1, "rank": 0, "parentId": -1,
                 "parentName": None},
                {"id": 28, "name": "算法", "type": 1, "rank": 1, "parentId": 27, "parentName": None},
                {"id": 29, "name": "面试", "type": 1, "rank": 2, "parentId": 28, "parentName": None},
                {"id": 30, "name": "多线程", "type": 1, "rank": 2, "parentId": 5, "parentName": None},
                {"id": 31, "name": "博客", "type": 0, "rank": 2, "parentId": 2, "parentName": None},
                {"id": 32, "name": "多线程基础", "type": 0, "rank": 2, "parentId": 14, "parentName": None},
                {"id": 33, "name": "JUC原子类", "type": 0, "rank": 2, "parentId": 14, "parentName": None},
                {"id": 35, "name": "JUC锁", "type": 0, "rank": 2, "parentId": 14, "parentName": None},
                {"id": 37, "name": "JUC集合", "type": 0, "rank": 2, "parentId": 14, "parentName": None},
                {"id": 38, "name": "Java集合", "type": 0, "rank": 2, "parentId": 11, "parentName": None},
                {"id": 39, "name": "SpringBoot", "type": 0, "rank": 2, "parentId": 24,
                 "parentName": None},
                {"id": 41, "name": "JUC线程池", "type": 0, "rank": 2, "parentId": 14, "parentName": None},
                {"id": 42, "name": "面试", "type": 0, "rank": 1, "parentId": 1, "parentName": None},
                {"id": 43, "name": "数据结构与算法", "type": 0, "rank": 0, "parentId": -1,
                 "parentName": None},
                {"id": 44, "name": "线性结构", "type": 0, "rank": 1, "parentId": 43, "parentName": None},
                {"id": 45, "name": "树形结构", "type": 0, "rank": 1, "parentId": 43, "parentName": None},
                {"id": 46, "name": "堆", "type": 0, "rank": 1, "parentId": 43, "parentName": None},
                {"id": 47, "name": "图", "type": 0, "rank": 1, "parentId": 43, "parentName": None},
                {"id": 48, "name": "排序算法", "type": 0, "rank": 1, "parentId": 43, "parentName": None},
                {"id": 49, "name": "数据库", "type": 1, "rank": 0, "parentId": -1, "parentName": None},
                {"id": 50, "name": "MySQL", "type": 1, "rank": 1, "parentId": 49, "parentName": None}]
        return Response(data)


class TagViewSet(GenericViewSet, ListModelMixin):
    authentication_classes = (TokenAuthentication,)
    permission_classes = (AllowAny,)

    def list(self, request, *args, **kwargs):
        data = [{"id": None, "name": "Arthas", "type": None, "linkNum": "1"},
                {"id": None, "name": "ElasticSearch", "type": None, "linkNum": "1"},
                {"id": None, "name": "Gitalk", "type": None, "linkNum": "1"},
                {"id": None, "name": "Java", "type": None, "linkNum": "54"},
                {"id": None, "name": "Java集合", "type": None, "linkNum": "8"},
                {"id": None, "name": "JUC原子类", "type": None, "linkNum": "5"},
                {"id": None, "name": "JUC线程池", "type": None, "linkNum": "6"},
                {"id": None, "name": "JUC锁", "type": None, "linkNum": "11"},
                {"id": None, "name": "JUC集合", "type": None, "linkNum": "0"},
                {"id": None, "name": "JVM", "type": None, "linkNum": "11"},
                {"id": None, "name": "leetcode", "type": None, "linkNum": "1"},
                {"id": None, "name": "MySQL", "type": None, "linkNum": "2"},
                {"id": None, "name": "Spring", "type": None, "linkNum": "2"},
                {"id": None, "name": "SpringBoot", "type": None, "linkNum": "1"},
                {"id": None, "name": "关于", "type": None, "linkNum": "1"},
                {"id": None, "name": "写作", "type": None, "linkNum": "1"},
                {"id": None, "name": "多线程", "type": None, "linkNum": "1"},
                {"id": None, "name": "多线程基础", "type": None, "linkNum": "9"},
                {"id": None, "name": "招聘", "type": None, "linkNum": "1"},
                {"id": None, "name": "本站相关", "type": None, "linkNum": "1"},
                {"id": None, "name": "算法", "type": None, "linkNum": "1"},
                {"id": None, "name": "设计模式", "type": None, "linkNum": "1"},
                {"id": None, "name": "部署相关", "type": None, "linkNum": "1"},
                {"id": None, "name": "面试", "type": None, "linkNum": "3"}]
        return Response(data)
